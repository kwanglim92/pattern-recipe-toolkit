<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레시피 뷰어</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; }
        .toast {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); background-color: #2d3748;
            color: white; padding: 10px 20px; border-radius: 8px;
            opacity: 0; transition: opacity 0.3s ease-in-out; z-index: 1000;
        }
        .toast.show { opacity: 1; }
        canvas { background-color: #f9fafb; border-radius: 0.5rem; border: 1px solid #e5e7eb; }
        #recipe-list a.active { background-color: #e0e7ff; color: #3730a3; }
        .table-container { max-height: 20rem; overflow-y: auto; }
        .data-table { width: 100%; border-collapse: collapse; }
        .data-table th, .data-table td { border: 1px solid #e5e7eb; padding: 6px 8px; text-align: right; font-size: 0.8rem; }
        .data-table th { background-color: #f3f4f6; font-weight: 600; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">레시피 뷰어 대시보드</h1>
            <p class="mt-2 text-gray-600">장비 엔지니어를 위한 검증된 레시피 정보 확인</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            <!-- 레시피 목록 및 정보 -->
            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg space-y-4">
                <div>
                    <h2 class="text-xl font-semibold mb-2">1. 레시피 불러오기</h2>
                    <input type="file" id="recipeFiles" multiple accept=".json" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"/>
                </div>
                <div class="pt-4 border-t">
                    <h2 class="text-xl font-semibold mb-2">2. 레시피 목록</h2>
                    <div id="recipe-summary" class="mb-3 p-2 bg-gray-50 rounded text-sm text-gray-600 hidden">
                        총 <span id="total-recipes">0</span>개 레시피, <span id="total-wafer-types">0</span>종류 웨이퍼
                    </div>
                    <div id="recipe-list" class="space-y-3 max-h-80 overflow-y-auto">
                        <p class="text-gray-500">여기에 레시피 파일을 불러오세요.</p>
                    </div>
                </div>
                <div id="recipe-info" class="hidden pt-4 border-t space-y-3">
                    <h2 class="text-xl font-semibold">3. 레시피 정보</h2>
                    <div>
                        <h3 class="font-semibold">샘플 S/N: <span id="info-sn" class="font-normal">-</span></h3>
                        <p class="text-sm text-gray-500">내보낸 시각: <span id="info-timestamp">-</span></p>
                    </div>
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        <p>웨이퍼 직경: <span id="info-diameter" class="font-mono">-</span></p>
                        <p>다이 피치 X: <span id="info-pitch-x" class="font-mono">-</span> µm</p>
                        <p>다이 피치 Y: <span id="info-pitch-y" class="font-mono">-</span> µm</p>
                        <p>선택된 다이: <span id="info-die-count" class="font-mono">-</span> 개</p>
                    </div>
                    <div class="flex space-x-2 mb-4">
                         <button id="exportBtn" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors shadow-md">
                            엑셀 보고서 내보내기
                        </button>
                        <button id="copyBtn" class="w-full bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors shadow-md">
                            현재 탭 복사
                        </button>
                    </div>
                    
                    <!-- 라인별 뷰어 생성 섹션 -->
                    <div id="line-viewer-section" class="pt-4 border-t border-gray-300 hidden">
                        <h3 class="text-lg font-semibold mb-3">라인별 전용 뷰어 생성</h3>
                        <div class="space-y-3">
                            <div>
                                <label for="line-name" class="block text-sm font-medium text-gray-700 mb-1">라인명</label>
                                <input type="text" id="line-name" placeholder="예: Production-Line-A" class="w-full p-2 border border-gray-300 rounded-md text-sm">
                            </div>
                            <div class="text-sm text-gray-600">
                                <p class="mb-2">내보낼 레시피 선택:</p>
                                <div id="recipe-selection-list" class="space-y-1 max-h-32 overflow-y-auto border border-gray-200 rounded p-2 bg-gray-50">
                                    <p class="text-gray-500 text-xs">레시피를 불러오면 여기에 선택 옵션이 나타납니다.</p>
                                </div>
                            </div>
                            <div class="flex space-x-2">
                                <button id="select-all-recipes" class="flex-1 bg-blue-500 text-white py-2 px-3 rounded text-sm hover:bg-blue-600">전체 선택</button>
                                <button id="deselect-all-recipes" class="flex-1 bg-gray-400 text-white py-2 px-3 rounded text-sm hover:bg-gray-500">전체 해제</button>
                            </div>
                            <button id="generate-line-viewer" class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-colors shadow-md">
                                라인 전용 뷰어 생성
                            </button>
                        </div>
                    </div>
                </div>
                
                <div id="intradie-info" class="hidden pt-4 border-t space-y-3">
                    <h2 class="text-xl font-semibold">4. 다이 내부 패턴 맵</h2>
                    <p class="text-sm text-gray-600">각 패턴이 다이 내부에서 어떻게 분포되어 있는지 보여줍니다.</p>
                    <div class="relative">
                        <canvas id="intraDieCanvas" width="300" height="300" class="w-full max-w-sm mx-auto"></canvas>
                        <div id="intraDieTooltip" class="tooltip"></div>
                    </div>
                </div>
            </div>

            <!-- 시각화 및 좌표 -->
            <div id="viewer-content" class="lg:col-span-3 bg-white p-6 rounded-xl shadow-lg space-y-6 hidden">
                 <div>
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-xl font-semibold">5. 패턴 시각화</h2>
                        <div class="flex items-center space-x-4">
                             <div class="flex items-center">
                                <input type="checkbox" id="v_showDieMapToggle" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                <label for="v_showDieMapToggle" class="ml-2 text-sm font-medium text-gray-700">다이 맵 표시</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="v_showPathToggle" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500" checked>
                                <label for="v_showPathToggle" class="ml-2 text-sm font-medium text-gray-700">경로 표시</label>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-between items-center mb-2">
                        <div id="pattern-legend" class="flex flex-wrap gap-x-4 gap-y-1 text-sm"></div>
                        <button id="v_toggleAllPatterns" class="text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded">모든 패턴 숨기기</button>
                    </div>
                    <canvas id="waferCanvas"></canvas>
                </div>
                <div>
                    <h2 class="text-xl font-semibold mb-2">6. 생성된 전체 좌표 목록</h2>
                     <p class="text-sm text-gray-600 mb-2">총 <span id="pointCount">0</span>개의 좌표</p>
                    <div>
                        <div class="border-b border-gray-200">
                            <nav id="tab-headers" class="-mb-px flex space-x-4 overflow-x-auto" aria-label="Tabs"></nav>
                        </div>
                        <div id="tab-contents" class="mt-4"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="toast" class="toast">클립보드에 복사되었습니다!</div>

    <script>
        // --- GLOBALS ---
        let loadedRecipes = [];
        let activeRecipe = null;
        let patternVisibility = {}; // 패턴 표시 상태 관리
        let allPatternsVisible = true; // 전체 패턴 표시 상태
        let currentDieMapData = null; // 현재 다이 맵 데이터 저장
        let currentIntraDiePatterns = null; // 현재 다이 내부 패턴 데이터 저장

        // --- DOM ELEMENTS ---
        const recipeFileInput = document.getElementById('recipeFiles');
        const recipeListDiv = document.getElementById('recipe-list');
        const recipeInfoDiv = document.getElementById('recipe-info');
        const viewerContentDiv = document.getElementById('viewer-content');
        const intraDieInfoDiv = document.getElementById('intradie-info');
        const intraDieCanvas = document.getElementById('intraDieCanvas');
        const intraDieCtx = intraDieCanvas.getContext('2d');
        const intraDieTooltip = document.getElementById('intraDieTooltip');
        
        // 새로운 컨트롤 요소들
        const v_showDieMapToggle = document.getElementById('v_showDieMapToggle');
        const v_showPathToggle = document.getElementById('v_showPathToggle');
        const v_toggleAllPatterns = document.getElementById('v_toggleAllPatterns');
        
        // 라인 뷰어 관련 요소들
        const lineViewerSection = document.getElementById('line-viewer-section');
        const lineNameInput = document.getElementById('line-name');
        const recipeSelectionList = document.getElementById('recipe-selection-list');
        const selectAllRecipesBtn = document.getElementById('select-all-recipes');
        const deselectAllRecipesBtn = document.getElementById('deselect-all-recipes');
        const generateLineViewerBtn = document.getElementById('generate-line-viewer');
        
        const infoSN = document.getElementById('info-sn');
        const infoTimestamp = document.getElementById('info-timestamp');
        const infoDiameter = document.getElementById('info-diameter');
        const infoPitchX = document.getElementById('info-pitch-x');
        const infoPitchY = document.getElementById('info-pitch-y');
        const infoDieCount = document.getElementById('info-die-count');

        const patternLegend = document.getElementById('pattern-legend');
        const waferCanvas = document.getElementById('waferCanvas');
        const waferCtx = waferCanvas.getContext('2d');
        const pointCountSpan = document.getElementById('pointCount');
        const tabHeadersContainer = document.getElementById('tab-headers');
        const tabContentsContainer = document.getElementById('tab-contents');
        
        const exportBtn = document.getElementById('exportBtn');
        const copyBtn = document.getElementById('copyBtn');
        const toast = document.getElementById('toast');

        // --- FILE HANDLING ---
        recipeFileInput.addEventListener('change', handleFileLoad);

        function handleFileLoad(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            loadedRecipes = [];
            const promises = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const recipe = JSON.parse(e.target.result);
                            if (recipe.sampleSN && recipe.inputs) {
                                loadedRecipes.push(recipe);
                                resolve();
                            }
                        } catch (err) {
                            console.error(`Failed to parse ${file.name}:`, err);
                            reject();
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            });

            Promise.all(promises).then(() => {
                loadedRecipes.sort((a, b) => a.sampleSN.localeCompare(b.sampleSN));
                updateRecipeList();
                if (loadedRecipes.length > 0) {
                    displayRecipe(loadedRecipes[0].sampleSN);
                }
            });
        }

        function updateRecipeList() {
            recipeListDiv.innerHTML = '';
            const summaryDiv = document.getElementById('recipe-summary');
            const totalRecipesSpan = document.getElementById('total-recipes');
            const totalWaferTypesSpan = document.getElementById('total-wafer-types');
            
            if (loadedRecipes.length === 0) {
                recipeListDiv.innerHTML = '<p class="text-gray-500">유효한 레시피 파일이 없습니다.</p>';
                summaryDiv.classList.add('hidden');
                return;
            }
            
            // 웨이퍼 크기별로 그룹화
            const groupedByWafer = {};
            
            loadedRecipes.forEach(recipe => {
                // 웨이퍼 정보 추출 (신버전 또는 구버전 대응)
                let waferCategory;
                let waferSizeMM;
                
                if (recipe.waferInfo && recipe.waferInfo.category) {
                    // 신버전 (v1.1+)
                    waferCategory = recipe.waferInfo.category;
                    waferSizeMM = recipe.waferInfo.sizeMM;
                } else if (recipe.inputs && recipe.inputs.waferDiameterMM) {
                    // 구버전 호환
                    waferSizeMM = recipe.inputs.waferDiameterMM;
                    waferCategory = `${waferSizeMM}mm`;
                } else if (recipe.inputs && recipe.inputs.waferDiameter) {
                    // 아주 구버전 (µm 단위만 있는 경우)
                    waferSizeMM = recipe.inputs.waferDiameter / 1000;
                    waferCategory = `${waferSizeMM}mm`;
                } else {
                    waferCategory = '알 수 없음';
                    waferSizeMM = 0;
                }
                
                if (!groupedByWafer[waferCategory]) {
                    groupedByWafer[waferCategory] = {
                        recipes: [],
                        sizeMM: waferSizeMM
                    };
                }
                groupedByWafer[waferCategory].recipes.push(recipe);
            });
            
            // 요약 정보 업데이트
            const waferTypes = Object.keys(groupedByWafer);
            totalRecipesSpan.textContent = loadedRecipes.length;
            totalWaferTypesSpan.textContent = waferTypes.length;
            summaryDiv.classList.remove('hidden');
            
            // 라인 뷰어 섹션 표시 및 레시피 선택 리스트 업데이트
            lineViewerSection.classList.remove('hidden');
            updateRecipeSelectionList();
            
            // 웨이퍼 크기별로 정렬 (숫자 오름차순)
            const sortedWaferTypes = waferTypes.sort((a, b) => {
                const sizeA = groupedByWafer[a].sizeMM;
                const sizeB = groupedByWafer[b].sizeMM;
                return sizeA - sizeB;
            });
            
            // 각 웨이퍼 그룹 렌더링
            sortedWaferTypes.forEach((waferType, index) => {
                const group = groupedByWafer[waferType];
                const recipes = group.recipes;
                
                // 그룹 제목
                const groupHeader = document.createElement('div');
                groupHeader.className = 'flex items-center justify-between py-2 px-3 bg-blue-50 border border-blue-200 rounded-lg cursor-pointer hover:bg-blue-100';
                groupHeader.innerHTML = `
                    <div class="flex items-center">
                        <span class="w-4 h-4 mr-2 text-blue-600">▼</span>
                        <span class="font-semibold text-blue-800">${waferType}</span>
                    </div>
                    <span class="text-sm text-blue-600 bg-blue-100 px-2 py-1 rounded">${recipes.length}개 샘플</span>
                `;
                
                // 그룹 콘텐츠
                const groupContent = document.createElement('div');
                groupContent.className = 'ml-4 space-y-2';
                groupContent.style.display = index === 0 ? 'block' : 'none'; // 첫 번째 그룹만 기본 오픈
                
                // 그룹 내 레시피들 정렬 (샘플명 알파벳순)
                recipes.sort((a, b) => a.sampleSN.localeCompare(b.sampleSN));
                
                recipes.forEach(recipe => {
                    const a = document.createElement('a');
                    a.href = '#';
                    a.dataset.sn = recipe.sampleSN;
                    a.className = 'block p-3 rounded-md hover:bg-gray-100 border border-gray-200';
                    
                    const displayName = recipe.fileName || recipe.sampleSN;
                    a.innerHTML = `
                        <p class="font-semibold text-gray-800">${displayName}</p>
                        <p class="text-sm text-gray-500">${new Date(recipe.exportTimestamp).toLocaleString()}</p>
                        <p class="text-xs text-gray-400">S/N: ${recipe.sampleSN}</p>
                    `;
                    a.onclick = (e) => {
                        e.preventDefault();
                        displayRecipe(recipe.sampleSN);
                    };
                    groupContent.appendChild(a);
                });
                
                // 그룹 토글 기능
                groupHeader.onclick = () => {
                    const isVisible = groupContent.style.display === 'block';
                    groupContent.style.display = isVisible ? 'none' : 'block';
                    const arrow = groupHeader.querySelector('span');
                    arrow.textContent = isVisible ? '▶' : '▼';
                };
                
                recipeListDiv.appendChild(groupHeader);
                recipeListDiv.appendChild(groupContent);
            });
        }

        // --- DISPLAY LOGIC ---
        function displayRecipe(sampleSN) {
            const recipe = loadedRecipes.find(r => r.sampleSN === sampleSN);
            if (!recipe) return;
            activeRecipe = recipe;

            // Highlight active item in list
            document.querySelectorAll('#recipe-list a').forEach(a => {
                a.classList.toggle('active', a.dataset.sn === sampleSN);
            });

            // Show info and content divs
            recipeInfoDiv.classList.remove('hidden');
            viewerContentDiv.classList.remove('hidden');
            intraDieInfoDiv.classList.remove('hidden');

            // Populate info
            infoSN.textContent = recipe.fileName || recipe.sampleSN;
            infoTimestamp.textContent = new Date(recipe.exportTimestamp).toLocaleString();
            
            // 웨이퍼 직경 정보 표시 (신버전에서는 mm 단위 우선 표시)
            if (recipe.waferInfo && recipe.waferInfo.sizeMM) {
                infoDiameter.textContent = `${recipe.waferInfo.sizeMM}mm (${recipe.inputs.waferDiameter}µm)`;
            } else if (recipe.inputs.waferDiameterMM) {
                infoDiameter.textContent = `${recipe.inputs.waferDiameterMM}mm (${recipe.inputs.waferDiameter}µm)`;
            } else {
                infoDiameter.textContent = recipe.inputs.waferDiameter;
            }
            
            infoPitchX.textContent = recipe.inputs.diePitchX;
            infoPitchY.textContent = recipe.inputs.diePitchY;
            infoDieCount.textContent = recipe.results.selectedDieCount;
            pointCountSpan.textContent = recipe.results.totalPointCount;

            // Re-create necessary data for visualization
            const { waferDiameter, diePitchX, diePitchY } = recipe.inputs;
            const waferRadius = waferDiameter / 2;
            const maxIndexX = Math.ceil(waferRadius / diePitchX);
            const maxIndexY = Math.ceil(waferRadius / diePitchY);
            const maxLayer = Math.max(maxIndexX, maxIndexY);
            
            let dieMapData = [];
            let x = 0, y = 0, dx = 0, dy = -1;
            for (let i = 0; i < (maxLayer * 2 + 1) ** 2; i++) {
                if ((-maxLayer <= x && x <= maxLayer) && (-maxLayer <= y && y <= maxLayer)) {
                    const onWafer = Math.sqrt((x * diePitchX) ** 2 + (y * diePitchY) ** 2) <= waferRadius;
                    const isSelected = recipe.selection.selectedDieIndices.includes(`${x},${y}`);
                    dieMapData.push({ i: x, j: y, onWafer, selected: isSelected });
                }
                if (x === y || (x < 0 && x === -y) || (x > 0 && x === 1 - y)) { [dx, dy] = [-dy, dx]; }
                x += dx; y += dy;
            }
            
            const colors = ['#2563eb', '#f97316', '#10b981', '#ec4899', '#8b5cf6', '#d97706'];
            const intraDiePatterns = recipe.inputs.intraDiePatternsRaw.split('\n').map((line, index) => {
                const parts = line.split(',');
                if (parts.length < 2) return null;
                const name = parts.length >= 3 ? parts[0].trim() : null;
                const x = parseFloat(parts[parts.length - 2]);
                const y = parseFloat(parts[parts.length - 1]);
                return { name, x, y, color: colors[index % colors.length] };
            }).filter(Boolean);
            
            // 패턴 가시성 상태 초기화
            patternVisibility = {};
            intraDiePatterns.forEach((p, index) => {
                const patternKey = p.name || `Pattern ${index + 1}`;
                patternVisibility[patternKey] = true; // 기본적으로 모두 보이기
            });
            allPatternsVisible = true;

            // 데이터 전역 변수에 저장
            currentDieMapData = dieMapData;
            currentIntraDiePatterns = intraDiePatterns;
            
            // Update UI
            updateResultTabs(recipe.results.visibleGroupedPoints);
            drawPatternVisualization(recipe, dieMapData, intraDiePatterns);
            drawIntraDieVisualization(intraDiePatterns);
        }

        function updateResultTabs(groupedPoints) {
            tabHeadersContainer.innerHTML = '';
            tabContentsContainer.innerHTML = '';
            let isFirstTab = true;

            for (const patternKey in groupedPoints) {
                if (groupedPoints[patternKey].length === 0) continue;
                const tabButton = document.createElement('button');
                tabButton.textContent = patternKey;
                tabButton.dataset.target = `tab-content-${patternKey.replace(/["\s(),]/g, '-')}`;
                tabButton.className = 'whitespace-nowrap py-2 px-3 border-b-2 font-medium text-sm rounded-t-md';

                const tabContent = document.createElement('div');
                tabContent.id = tabButton.dataset.target;
                tabContent.className = 'table-container';
                const table = document.createElement('table');
                table.className = 'data-table';
                
                const headerHTML = `<thead><tr><th>Pattern No.</th><th>Grid X</th><th>Grid Y</th><th>X</th><th>Y</th></tr></thead>`;
                const rowsHTML = groupedPoints[patternKey].map((p, index) => `<tr><td>${index + 1}</td><td>${p.i}</td><td>${p.j}</td><td>${p.x.toFixed(0)}</td><td>${p.y.toFixed(0)}</td></tr>`).join('');
                table.innerHTML = headerHTML + `<tbody>${rowsHTML}</tbody>`;
                
                tabContent.appendChild(table);

                if (isFirstTab) {
                    tabButton.classList.add('border-blue-500', 'text-blue-600', 'bg-blue-50');
                    tabContent.style.display = 'block';
                    isFirstTab = false;
                } else {
                    tabButton.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-200');
                    tabContent.style.display = 'none';
                }

                tabButton.addEventListener('click', (e) => {
                    document.querySelectorAll('#tab-headers button').forEach(btn => {
                        btn.classList.remove('border-blue-500', 'text-blue-600', 'bg-blue-50');
                        btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-200');
                    });
                    document.querySelectorAll('#tab-contents > div').forEach(content => {
                        content.style.display = 'none';
                    });

                    e.target.classList.add('border-blue-500', 'text-blue-600', 'bg-blue-50');
                    document.getElementById(e.target.dataset.target).style.display = 'block';
                });

                tabHeadersContainer.appendChild(tabButton);
                tabContentsContainer.appendChild(tabContent);
            }
        }

        function drawPatternVisualization(recipe, dieMapData, intraDiePatterns) {
            console.log('drawPatternVisualization 호출:', { recipe: !!recipe, dieMapData: !!dieMapData, intraDiePatterns: !!intraDiePatterns });
            
            if (!recipe || !recipe.inputs) {
                console.error('레시피 데이터가 없습니다');
                return;
            }
            
            const { waferDiameter, diePitchX, diePitchY } = recipe.inputs;
            const waferRadius = waferDiameter / 2;
            const visiblePoints = Object.values(recipe.results.visibleGroupedPoints).flat();

            const canvas = waferCanvas;
            const ctx = waferCtx;
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientWidth;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const padding = 30;
            const scale = Math.min((canvas.width - 2 * padding) / waferDiameter, (canvas.height - 2 * padding) / waferDiameter);
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw die map
            const dieWidth = diePitchX * scale;
            const dieHeight = diePitchY * scale;
            dieMapData.forEach(die => {
                const dieCenterX = centerX + die.i * diePitchX * scale;
                const dieCenterY = centerY - die.j * diePitchY * scale;
                if (die.onWafer) {
                    ctx.fillStyle = die.selected ? 'rgba(74, 222, 128, 0.2)' : 'rgba(239, 68, 68, 0.2)';
                } else {
                    ctx.fillStyle = 'rgba(209, 213, 219, 0.2)';
                }
                ctx.fillRect(dieCenterX - dieWidth / 2, dieCenterY - dieHeight / 2, dieWidth, dieHeight);
                ctx.strokeStyle = die.selected ? 'rgba(156, 163, 175, 0.5)' : 'rgba(239, 68, 68, 0.4)';
                ctx.strokeRect(dieCenterX - dieWidth / 2, dieCenterY - dieHeight / 2, dieWidth, dieHeight);
            });

            // Draw wafer circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, waferRadius * scale, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw points
            // 패턴 별 필터링 및 그리기
            const showDieMap = v_showDieMapToggle.checked;
            const showPath = v_showPathToggle.checked;
            
            // 다이 맵 표시
            if (showDieMap && dieMapData) {
                const dieWidth = diePitchX * scale;
                const dieHeight = diePitchY * scale;
                dieMapData.forEach(die => {
                    const dieCenterX = centerX + die.i * diePitchX * scale;
                    const dieCenterY = centerY - die.j * diePitchY * scale;
                    if (die.onWafer) {
                        ctx.fillStyle = die.selected ? 'rgba(74, 222, 128, 0.2)' : 'rgba(239, 68, 68, 0.2)';
                    } else {
                        ctx.fillStyle = 'rgba(209, 213, 219, 0.2)';
                    }
                    ctx.fillRect(dieCenterX - dieWidth / 2, dieCenterY - dieHeight / 2, dieWidth, dieHeight);
                    ctx.strokeStyle = die.selected ? 'rgba(156, 163, 175, 0.5)' : 'rgba(239, 68, 68, 0.4)';
                    ctx.strokeRect(dieCenterX - dieWidth / 2, dieCenterY - dieHeight / 2, dieWidth, dieHeight);
                });
            }
            
            // 경로 표시
            if (showPath) {
                const pointsByColor = {};
                visiblePoints.forEach(p => {
                    if (intraDiePatterns) {
                        const patternName = getPatternNameFromColor(p.color, intraDiePatterns);
                        if (patternVisibility[patternName] !== false) {
                            if (!pointsByColor[p.color]) pointsByColor[p.color] = [];
                            pointsByColor[p.color].push(p);
                        }
                    } else {
                        if (!pointsByColor[p.color]) pointsByColor[p.color] = [];
                        pointsByColor[p.color].push(p);
                    }
                });

                for (const color in pointsByColor) {
                    const pathPoints = pointsByColor[color];
                    if(pathPoints.length === 0) continue;
                    ctx.beginPath();
                    const firstPoint = pathPoints[0];
                    ctx.moveTo(centerX + firstPoint.x * scale, centerY - firstPoint.y * scale);
                    for (let i = 1; i < pathPoints.length; i++) {
                        const p = pathPoints[i];
                        ctx.lineTo(centerX + p.x * scale, centerY - p.y * scale);
                    }
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            
            // 패턴 점들 그리기 (표시 설정에 따라 필터링)
            visiblePoints.forEach(p => {
                let shouldDraw = true;
                if (intraDiePatterns) {
                    const patternName = getPatternNameFromColor(p.color, intraDiePatterns);
                    shouldDraw = patternVisibility[patternName] !== false;
                }
                
                if (shouldDraw) {
                    ctx.fillStyle = p.color;
                    const canvasX = centerX + p.x * scale;
                    const canvasY = centerY - p.y * scale;
                    ctx.beginPath();
                    ctx.arc(canvasX, canvasY, 2.5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // Draw legend with clickable items
            patternLegend.innerHTML = '';
            intraDiePatterns.forEach((p, index) => {
                const patternKey = p.name || `Pattern ${index + 1}`;
                const isVisible = patternVisibility[patternKey] !== false; // 기본값 true
                
                const legendItem = document.createElement('div');
                legendItem.className = `flex items-center cursor-pointer hover:bg-gray-100 px-2 py-1 rounded ${isVisible ? '' : 'opacity-50'}`;
                legendItem.innerHTML = `
                    <input type="checkbox" ${isVisible ? 'checked' : ''} class="mr-2" data-pattern="${patternKey}">
                    <div class="w-3 h-3 rounded-full mr-1.5" style="background-color: ${p.color};"></div>
                    <span>${patternKey}</span>
                `;
                
                // 체크박스 이벤트 리스너
                const checkbox = legendItem.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', function() {
                    patternVisibility[patternKey] = this.checked;
                    if (activeRecipe && currentDieMapData && currentIntraDiePatterns) {
                        drawPatternVisualization(activeRecipe, currentDieMapData, currentIntraDiePatterns);
                    }
                });
                
                // 전체 항목 클릭으로도 토글 가능
                legendItem.addEventListener('click', function(e) {
                    if (e.target.tagName !== 'INPUT') {
                        checkbox.checked = !checkbox.checked;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                });
                
                patternLegend.appendChild(legendItem);
            });
            
            // 전체 패턴 토글 버튼 업데이트
            updateToggleAllButton();
        }
        
        function drawIntraDieVisualization(intraDiePatterns) {
            const canvas = intraDieCanvas;
            const ctx = intraDieCtx;
            
            // 적절한 캔버스 크기 설정
            const container = canvas.parentElement;
            const canvasSize = Math.min(container.clientWidth, 300);
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!intraDiePatterns || intraDiePatterns.length === 0) {
                ctx.fillStyle = '#9ca3af';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('다이 내부 패턴 정보가 없습니다', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // 패턴 좌표 범위 계산
            const xCoords = intraDiePatterns.map(p => p.x);
            const yCoords = intraDiePatterns.map(p => p.y);
            const minX = Math.min(...xCoords, 0);
            const maxX = Math.max(...xCoords, 0);
            const minY = Math.min(...yCoords, 0);
            const maxY = Math.max(...yCoords, 0);
            
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const maxRange = Math.max(rangeX, rangeY);
            
            // 스케일 및 오프셋 계산
            const padding = 40;
            const scale = (canvas.width - 2 * padding) / maxRange * 0.8;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // 배경 그리드 그리기
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            // 중심 좍
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            ctx.setLineDash([]); // 점선 해제
            
            // 원점 표시
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText('(0,0)', centerX + 5, centerY + 5);
            
            // 패턴 그리기
            const colors = ['#2563eb', '#f97316', '#10b981', '#ec4899', '#8b5cf6', '#d97706'];
            let renderedIntraDiePoints = [];
            
            intraDiePatterns.forEach((pattern, index) => {
                const canvasX = centerX + pattern.x * scale;
                const canvasY = centerY - pattern.y * scale; // Y축 반전
                const color = colors[index % colors.length];
                
                // 패턴 점 그리기
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // 패턴 이름 표시
                if (pattern.name) {
                    ctx.fillStyle = '#374151';
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(pattern.name, canvasX, canvasY - 8);
                }
                
                // 마우스 인터랙션을 위해 저장
                renderedIntraDiePoints.push({
                    x: canvasX,
                    y: canvasY,
                    data: pattern
                });
            });
            
            // 마우스 인터랙션 이벤트 설정
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                let foundPoint = null;
                for (const point of renderedIntraDiePoints) {
                    const distance = Math.sqrt((point.x - mouseX)**2 + (point.y - mouseY)**2);
                    if (distance < 10) {
                        foundPoint = point;
                        break;
                    }
                }
                
                if (foundPoint) {
                    intraDieTooltip.style.display = 'block';
                    intraDieTooltip.style.left = `${canvas.offsetLeft + foundPoint.x + 15}px`;
                    intraDieTooltip.style.top = `${canvas.offsetTop + foundPoint.y - 10}px`;
                    
                    let tooltipHTML = '';
                    if (foundPoint.data.imageUrl) {
                        tooltipHTML += `<img src="${foundPoint.data.imageUrl}" alt="${foundPoint.data.name || 'Pattern'}" style="max-width: 80px; max-height: 80px; margin-bottom: 4px;"><br>`;
                    }
                    tooltipHTML += `<strong>${foundPoint.data.name || 'Pattern'}</strong><br>`;
                    tooltipHTML += `X: ${foundPoint.data.x}µm, Y: ${foundPoint.data.y}µm`;
                    intraDieTooltip.innerHTML = tooltipHTML;
                } else {
                    intraDieTooltip.style.display = 'none';
                }
            };
            
            canvas.onmouseleave = () => {
                intraDieTooltip.style.display = 'none';
            };
        }
        
        // 레시피 선택 리스트 업데이트
        function updateRecipeSelectionList() {
            recipeSelectionList.innerHTML = '';
            
            if (loadedRecipes.length === 0) {
                recipeSelectionList.innerHTML = '<p class="text-gray-500 text-xs">레시피를 불러오면 여기에 선택 옵션이 나타납니다.</p>';
                return;
            }
            
            loadedRecipes.forEach((recipe, index) => {
                const checkboxItem = document.createElement('div');
                checkboxItem.className = 'flex items-center space-x-2';
                
                const displayName = recipe.fileName || recipe.sampleSN;
                const waferInfo = recipe.waferInfo ? `${recipe.waferInfo.sizeMM}mm` : 
                                 recipe.inputs.waferDiameterMM ? `${recipe.inputs.waferDiameterMM}mm` : 
                                 recipe.inputs.waferDiameter ? `${recipe.inputs.waferDiameter / 1000}mm` : 'Unknown';
                
                checkboxItem.innerHTML = `
                    <input type="checkbox" id="recipe-${index}" class="recipe-checkbox" data-recipe-index="${index}" checked>
                    <label for="recipe-${index}" class="text-xs cursor-pointer flex-1">
                        <span class="font-medium">${displayName}</span>
                        <span class="text-gray-500 ml-1">(${waferInfo})</span>
                    </label>
                `;
                
                recipeSelectionList.appendChild(checkboxItem);
            });
        }
        
        // 전체 레시피 선택/해제 기능
        function selectAllRecipes(select = true) {
            document.querySelectorAll('.recipe-checkbox').forEach(checkbox => {
                checkbox.checked = select;
            });
        }
        
        // 선택된 레시피 가져오기
        function getSelectedRecipes() {
            const selectedRecipes = [];
            document.querySelectorAll('.recipe-checkbox:checked').forEach(checkbox => {
                const recipeIndex = parseInt(checkbox.dataset.recipeIndex);
                selectedRecipes.push(loadedRecipes[recipeIndex]);
            });
            return selectedRecipes;
        }
        
        // 패턴 색상에서 패턴명 찾기
        function getPatternNameFromColor(color, intraDiePatterns) {
            const pattern = intraDiePatterns.find(p => p.color === color);
            return pattern ? (pattern.name || `Pattern ${intraDiePatterns.indexOf(pattern) + 1}`) : 'Unknown';
        }
        
        // 전체 패턴 토글 버튼 업데이트
        function updateToggleAllButton() {
            const visibleCount = Object.values(patternVisibility).filter(v => v !== false).length;
            const totalCount = Object.keys(patternVisibility).length;
            
            if (visibleCount === totalCount || totalCount === 0) {
                v_toggleAllPatterns.textContent = '모든 패턴 숨기기';
                allPatternsVisible = true;
            } else {
                v_toggleAllPatterns.textContent = '모든 패턴 보이기';
                allPatternsVisible = false;
            }
        }
        
        // 전체 패턴 토글 기능
        function toggleAllPatterns() {
            const newState = !allPatternsVisible;
            
            Object.keys(patternVisibility).forEach(patternKey => {
                patternVisibility[patternKey] = newState;
            });
            
            allPatternsVisible = newState;
            
            // 모든 체크박스 업데이트
            document.querySelectorAll('#pattern-legend input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = newState;
            });
            
            updateToggleAllButton();
            
            // 시각화 업데이트
            if (activeRecipe && currentDieMapData && currentIntraDiePatterns) {
                drawPatternVisualization(activeRecipe, currentDieMapData, currentIntraDiePatterns);
            }
        }

        // --- ACTIONS ---
        copyBtn.addEventListener('click', () => {
            const activeTable = document.querySelector('#tab-contents > div:not([style*="display: none"]) table');
            if (!activeTable) return;
            
            let tsvContent = '';
            activeTable.querySelectorAll('tr').forEach(row => {
                const rowData = [];
                row.querySelectorAll('th, td').forEach(cell => { rowData.push(cell.innerText); });
                tsvContent += rowData.join('\t') + '\n';
            });

            navigator.clipboard.writeText(tsvContent).then(() => {
                toast.classList.add('show');
                setTimeout(() => { toast.classList.remove('show'); }, 2000);
            });
        });

        exportBtn.addEventListener('click', () => {
            if (!activeRecipe) {
                alert("먼저 레시피를 불러와주세요.");
                return;
            }
            exportToExcel(activeRecipe);
        });

        // 체크박스 이벤트 리스너 설정
        v_showDieMapToggle.addEventListener('change', () => {
            if (activeRecipe && currentDieMapData && currentIntraDiePatterns) {
                drawPatternVisualization(activeRecipe, currentDieMapData, currentIntraDiePatterns);
            }
        });
        
        v_showPathToggle.addEventListener('change', () => {
            if (activeRecipe && currentDieMapData && currentIntraDiePatterns) {
                drawPatternVisualization(activeRecipe, currentDieMapData, currentIntraDiePatterns);
            }
        });
        
        v_toggleAllPatterns.addEventListener('click', toggleAllPatterns);

        async function exportToExcel(recipe) {
            const workbook = new ExcelJS.Workbook();
            const { inputs, results, sampleSN } = recipe;

            // Summary Sheet
            const summarySheet = workbook.addWorksheet('Summary');
            summarySheet.columns = [ { header: 'Parameter', key: 'param', width: 25 }, { header: 'Value', key: 'value', width: 25 } ];
            summarySheet.addRow({ param: 'Sample S/N', value: sampleSN });
            summarySheet.addRow({ param: 'Wafer Diameter (µm)', value: inputs.waferDiameter });
            summarySheet.addRow({ param: 'Die Pitch X (µm)', value: inputs.diePitchX });
            summarySheet.addRow({ param: 'Die Pitch Y (µm)', value: inputs.diePitchY });
            summarySheet.addRow({ param: 'Selected Die Count', value: results.selectedDieCount });

            // Data Sheets
            for (const patternKey in results.visibleGroupedPoints) {
                const sheetData = results.visibleGroupedPoints[patternKey];
                if (sheetData.length === 0) continue;
                const sheet = workbook.addWorksheet(patternKey.substring(0, 31));
                sheet.columns = [
                    { header: 'Pattern No.', key: 'no', width: 12 },
                    { header: 'Grid X', key: 'gx', width: 10 },
                    { header: 'Grid Y', key: 'gy', width: 10 },
                    { header: 'X', key: 'x', width: 15 },
                    { header: 'Y', key: 'y', width: 15 },
                ];
                sheetData.forEach((p, index) => {
                    sheet.addRow({ no: index + 1, gx: p.i, gy: p.j, x: p.x, y: p.y });
                });
            }
            
            // Visualization Sheet
            const vizSheet = workbook.addWorksheet('Visualization');
            const patternImage = waferCanvas.toDataURL('image/png');
            const patternImageId = workbook.addImage({ base64: patternImage, extension: 'png' });
            vizSheet.addImage(patternImageId, {
                tl: { col: 0, row: 1 },
                ext: { width: 600, height: 600 }
            });

            // Download
            const buffer = await workbook.xlsx.writeBuffer();
            const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${sampleSN}_report.xlsx`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // --- LINE-SPECIFIC VIEWER FUNCTIONS ---
        function updateRecipeSelectionList() {
            const selectionList = document.getElementById('recipe-selection-list');
            if (loadedRecipes.length === 0) {
                selectionList.innerHTML = '<p class="text-gray-500 text-xs">레시피를 불러오면 여기에 선택 옵션이 나타납니다.</p>';
                return;
            }
            
            let html = '';
            loadedRecipes.forEach((recipe, index) => {
                const displayName = recipe.fileName || recipe.sampleSN || `Recipe ${index + 1}`;
                const waferInfo = recipe.waferInfo ? `${recipe.waferInfo.sizeMM}mm` : 
                                  recipe.inputs ? `${(recipe.inputs.waferDiameter / 1000).toFixed(0)}mm` : '';
                const waferDisplay = waferInfo ? ` (${waferInfo})` : '';
                
                html += `
                    <label class="flex items-center space-x-2 text-xs hover:bg-gray-100 p-1 rounded">
                        <input type="checkbox" class="recipe-checkbox" data-index="${index}" checked>
                        <span class="truncate">${displayName}${waferDisplay}</span>
                    </label>
                `;
            });
            selectionList.innerHTML = html;
        }

        function selectAllRecipes(select = true) {
            const checkboxes = document.querySelectorAll('.recipe-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = select;
            });
        }

        function getSelectedRecipes() {
            const checkboxes = document.querySelectorAll('.recipe-checkbox:checked');
            const selectedIndexes = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index));
            return selectedIndexes.map(index => loadedRecipes[index]);
        }

        function generateLineViewerHTML(lineName, selectedRecipes, generationDate) {
            const embedData = {
                lineName: lineName,
                generationDate: generationDate,
                recipes: selectedRecipes.map(recipe => ({
                    ...recipe,
                    // Remove any file references since this will be standalone
                    fileName: recipe.fileName || recipe.sampleSN || 'Recipe'
                }))
            };
            
            // HTML 템플릿을 문자열 연결 방식으로 생성하여 템플릿 리터럴 충돌 방지
            const htmlTemplate = '<!DOCTYPE html>\n' +
                '<html lang="ko">\n' +
                '<head>\n' +
                '    <meta charset="UTF-8">\n' +
                '    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
                '    <title>' + lineName + ' - 전용 레시피 뷰어</title>\n' +
                '    <script src="https://cdn.tailwindcss.com"></script>\n' +
                '    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">\n' +
                '    <style>\n' +
                '        body { font-family: \'Noto Sans KR\', sans-serif; }\n' +
                '        .toast {\n' +
                '            position: fixed; bottom: 20px; left: 50%;\n' +
                '            transform: translateX(-50%); background-color: #2d3748;\n' +
                '            color: white; padding: 10px 20px; border-radius: 8px;\n' +
                '            opacity: 0; transition: opacity 0.3s ease-in-out; z-index: 1000;\n' +
                '        }\n' +
                '        .toast.show { opacity: 1; }\n' +
                '        canvas { background-color: #f9fafb; border-radius: 0.5rem; border: 1px solid #e5e7eb; }\n' +
                '        #recipe-list a.active { background-color: #e0e7ff; color: #3730a3; }\n' +
                '        .table-container { max-height: 20rem; overflow-y: auto; }\n' +
                '        .data-table { width: 100%; border-collapse: collapse; }\n' +
                '        .data-table th, .data-table td { border: 1px solid #e5e7eb; padding: 6px 8px; text-align: right; font-size: 0.8rem; }\n' +
                '        .data-table th { background-color: #f3f4f6; font-weight: 600; }\n' +
                '    </style>\n' +
                '</head>\n' +
                '<body class="bg-gray-100 text-gray-800">\n' +
                '    <div class="container mx-auto p-4 md:p-8">\n' +
                '        <header class="text-center mb-8">\n' +
                '            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">' + lineName + '</h1>\n' +
                '            <h2 class="text-xl text-gray-600 mt-2">전용 레시피 뷰어</h2>\n' +
                '            <p class="mt-2 text-sm text-gray-500">생성일: ' + generationDate + '</p>\n' +
                '            <p class="text-sm text-gray-500">총 ' + selectedRecipes.length + '개 레시피</p>\n' +
                '        </header>\n' +
                '\n' +
                '        <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">\n' +
                '            <!-- 레시피 목록 및 정보 -->\n' +
                '            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg space-y-4">\n' +
                '                <div class="pt-4 border-t">\n' +
                '                    <h2 class="text-xl font-semibold mb-2">레시피 목록</h2>\n' +
                '                    <div class="mb-3 p-2 bg-gray-50 rounded text-sm text-gray-600">\n' +
                '                        총 ' + selectedRecipes.length + '개 레시피\n' +
                '                    </div>\n' +
                '                    <div id="recipe-list" class="space-y-3 max-h-80 overflow-y-auto">\n' +
                '                    </div>\n' +
                '                </div>\n' +
                '                \n' +
                '                <div id="recipe-info" class="hidden pt-4 border-t space-y-3">\n' +
                '                    <h2 class="text-xl font-semibold">레시피 정보</h2>\n' +
                '                    <div>\n' +
                '                        <h3 class="font-semibold">샘플 S/N: <span id="info-sn" class="font-normal">-</span></h3>\n' +
                '                        <p class="text-sm text-gray-500">내보낸 시각: <span id="info-timestamp">-</span></p>\n' +
                '                    </div>\n' +
                '                    <div class="grid grid-cols-2 gap-2 text-sm">\n' +
                '                        <p>웨이퍼 직경: <span id="info-diameter" class="font-mono">-</span></p>\n' +
                '                        <p>다이 피치 X: <span id="info-pitch-x" class="font-mono">-</span> µm</p>\n' +
                '                        <p>다이 피치 Y: <span id="info-pitch-y" class="font-mono">-</span> µm</p>\n' +
                '                        <p>선택된 다이: <span id="info-die-count" class="font-mono">-</span> 개</p>\n' +
                '                    </div>\n' +
                '                    <button id="copyBtn" class="w-full bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors shadow-md">\n' +
                '                        현재 탭 복사\n' +
                '                    </button>\n' +
                '                </div>\n' +
                '            </div>\n' +
                '\n' +
                '            <!-- 시각화 및 좌표 -->\n' +
                '            <div id="viewer-content" class="lg:col-span-3 bg-white p-6 rounded-xl shadow-lg space-y-6 hidden">\n' +
                '                <div>\n' +
                '                    <div class="flex justify-between items-center mb-2">\n' +
                '                        <h2 class="text-xl font-semibold">패턴 시각화</h2>\n' +
                '                        <div class="flex items-center space-x-4">\n' +
                '                            <div class="flex items-center">\n' +
                '                                <input type="checkbox" id="v_showDieMapToggle" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">\n' +
                '                                <label for="v_showDieMapToggle" class="ml-2 text-sm font-medium text-gray-700">다이 맵 표시</label>\n' +
                '                            </div>\n' +
                '                            <div class="flex items-center">\n' +
                '                                <input type="checkbox" id="v_showPathToggle" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500" checked>\n' +
                '                                <label for="v_showPathToggle" class="ml-2 text-sm font-medium text-gray-700">경로 표시</label>\n' +
                '                            </div>\n' +
                '                        </div>\n' +
                '                    </div>\n' +
                '                    <div class="flex justify-between items-center mb-2">\n' +
                '                        <div id="pattern-legend" class="flex flex-wrap gap-x-4 gap-y-1 text-sm"></div>\n' +
                '                        <button id="v_toggleAllPatterns" class="text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded">모든 패턴 숨기기</button>\n' +
                '                    </div>\n' +
                '                    <canvas id="waferCanvas"></canvas>\n' +
                '                </div>\n' +
                '                <div>\n' +
                '                    <h2 class="text-xl font-semibold mb-2">생성된 전체 좌표 목록</h2>\n' +
                '                    <p class="text-sm text-gray-600 mb-2">총 <span id="pointCount">0</span>개의 좌표</p>\n' +
                '                    <div>\n' +
                '                        <div class="border-b border-gray-200">\n' +
                '                            <nav id="tab-headers" class="-mb-px flex space-x-4 overflow-x-auto" aria-label="Tabs"></nav>\n' +
                '                        </div>\n' +
                '                        <div id="tab-contents" class="mt-4"></div>\n' +
                '                    </div>\n' +
                '                </div>\n' +
                '            </div>\n' +
                '        </div>\n' +
                '    </div>\n' +
                '    <div id="toast" class="toast">클립보드에 복사되었습니다!</div>\n' +
                '\n' +
                '    <script>\n' +
                '        // Embedded recipe data\n' +
                '        const EMBEDDED_DATA = ' + JSON.stringify(embedData, null, 8) + ';\n' +
                '        \n' +
                '        ' + getEmbeddedViewerScript() + '\n' +
                '    </script>\n' +
                '</body>\n' +
                '</html>';
                
            return htmlTemplate;
        }

        function getEmbeddedViewerScript() {
            // 문자열 연결 방식으로 JavaScript 코드 생성하여 템플릿 리터럴 충돌 방지
            return '// Initialize viewer with embedded data\n' +
                'let loadedRecipes = EMBEDDED_DATA.recipes;\n' +
                'let activeRecipe = null;\n' +
                'let patternVisibility = {};\n' +
                'let allPatternsVisible = true;\n' +
                'let currentDieMapData = null;\n' +
                'let currentIntraDiePatterns = null;\n' +
                '\n' +
                '// DOM Elements\n' +
                'const recipeList = document.getElementById(\'recipe-list\');\n' +
                'const recipeInfo = document.getElementById(\'recipe-info\');\n' +
                'const viewerContent = document.getElementById(\'viewer-content\');\n' +
                'const waferCanvas = document.getElementById(\'waferCanvas\');\n' +
                'const copyBtn = document.getElementById(\'copyBtn\');\n' +
                'const toast = document.getElementById(\'toast\');\n' +
                'const v_showDieMapToggle = document.getElementById(\'v_showDieMapToggle\');\n' +
                'const v_showPathToggle = document.getElementById(\'v_showPathToggle\');\n' +
                'const v_toggleAllPatterns = document.getElementById(\'v_toggleAllPatterns\');\n' +
                '\n' +
                'let waferCtx = null;\n' +
                '\n' +
                '// Initialize the viewer\n' +
                'document.addEventListener(\'DOMContentLoaded\', function() {\n' +
                '    if (waferCanvas) waferCtx = waferCanvas.getContext(\'2d\');\n' +
                '    displayRecipeList();\n' +
                '});\n' +
                '\n' +
                'function displayRecipeList() {\n' +
                '    let html = \'\';\n' +
                '    loadedRecipes.forEach((recipe, index) => {\n' +
                '        const displayName = recipe.fileName || recipe.sampleSN || (\'Recipe \' + (index + 1));\n' +
                '        const waferInfo = recipe.waferInfo ? (recipe.waferInfo.sizeMM + \'mm\') : \n' +
                '                          recipe.inputs ? ((recipe.inputs.waferDiameter / 1000).toFixed(0) + \'mm\') : \'\';\n' +
                '        const waferDisplay = waferInfo ? (\' (\' + waferInfo + \')\') : \'\';\n' +
                '        \n' +
                '        html += \'<a href="#" class="recipe-item block p-3 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors" data-index="\' + index + \'">\' +\n' +
                '               \'<div class="font-medium">\' + displayName + \'</div>\' +\n' +
                '               \'<div class="text-sm text-gray-500">웨이퍼: \' + waferDisplay + \'</div>\' +\n' +
                '               \'</a>\';\n' +
                '    });\n' +
                '    recipeList.innerHTML = html;\n' +
                '    \n' +
                '    // Add click event listeners\n' +
                '    document.querySelectorAll(\'.recipe-item\').forEach(item => {\n' +
                '        item.addEventListener(\'click\', (e) => {\n' +
                '            e.preventDefault();\n' +
                '            const index = parseInt(item.dataset.index);\n' +
                '            loadRecipe(loadedRecipes[index], index);\n' +
                '        });\n' +
                '    });\n' +
                '}\n' +
                '\n' +
                'function loadRecipe(recipe, index) {\n' +
                '    activeRecipe = recipe;\n' +
                '    \n' +
                '    // Update UI\n' +
                '    document.querySelectorAll(\'.recipe-item\').forEach(item => item.classList.remove(\'active\'));\n' +
                '    const activeItem = document.querySelector(\'[data-index="\' + index + \'"]\');\n' +
                '    if (activeItem) activeItem.classList.add(\'active\');\n' +
                '    \n' +
                '    displayRecipeInfo(recipe);\n' +
                '    \n' +
                '    const { dieMapData, intraDiePatterns } = processRecipeData(recipe);\n' +
                '    currentDieMapData = dieMapData;\n' +
                '    currentIntraDiePatterns = intraDiePatterns;\n' +
                '    \n' +
                '    drawPatternVisualization(recipe, dieMapData, intraDiePatterns);\n' +
                '    displayCoordinateTabs(recipe);\n' +
                '    \n' +
                '    recipeInfo.classList.remove(\'hidden\');\n' +
                '    viewerContent.classList.remove(\'hidden\');\n' +
                '}\n' +
                '\n' +
                'function displayRecipeInfo(recipe) {\n' +
                '    const { inputs, results, sampleSN, exportTime } = recipe;\n' +
                '    const infoSn = document.getElementById(\'info-sn\');\n' +
                '    const infoTimestamp = document.getElementById(\'info-timestamp\');\n' +
                '    const infoDiameter = document.getElementById(\'info-diameter\');\n' +
                '    const infoPitchX = document.getElementById(\'info-pitch-x\');\n' +
                '    const infoPitchY = document.getElementById(\'info-pitch-y\');\n' +
                '    const infoDieCount = document.getElementById(\'info-die-count\');\n' +
                '    \n' +
                '    if (infoSn) infoSn.textContent = sampleSN || \'-\';\n' +
                '    if (infoTimestamp) infoTimestamp.textContent = exportTime || \'-\';\n' +
                '    if (infoDiameter) infoDiameter.textContent = inputs ? ((inputs.waferDiameter / 1000).toFixed(0) + \'mm\') : \'-\';\n' +
                '    if (infoPitchX) infoPitchX.textContent = inputs ? inputs.diePitchX : \'-\';\n' +
                '    if (infoPitchY) infoPitchY.textContent = inputs ? inputs.diePitchY : \'-\';\n' +
                '    if (infoDieCount) infoDieCount.textContent = results ? results.selectedDieCount : \'-\';\n' +
                '}\n' +
                '\n' +
                'function processRecipeData(recipe) {\n' +
                '    const dieMapData = recipe.results?.dieMapData || [];\n' +
                '    const intraDiePatterns = recipe.results?.intraDiePatterns || {};\n' +
                '    return { dieMapData, intraDiePatterns };\n' +
                '}\n' +
                '\n' +
                'function displayCoordinateTabs(recipe) {\n' +
                '    const { results } = recipe;\n' +
                '    if (!results || !results.visibleGroupedPoints) return;\n' +
                '    \n' +
                '    const tabHeadersContainer = document.getElementById(\'tab-headers\');\n' +
                '    const tabContentsContainer = document.getElementById(\'tab-contents\');\n' +
                '    \n' +
                '    tabHeadersContainer.innerHTML = \'\';\n' +
                '    tabContentsContainer.innerHTML = \'\';\n' +
                '    \n' +
                '    const groupedPoints = results.visibleGroupedPoints;\n' +
                '    const totalPoints = Object.values(groupedPoints).reduce((sum, points) => sum + points.length, 0);\n' +
                '    const pointCountElement = document.getElementById(\'pointCount\');\n' +
                '    if (pointCountElement) pointCountElement.textContent = totalPoints;\n' +
                '    \n' +
                '    let isFirstTab = true;\n' +
                '    for (const patternKey in groupedPoints) {\n' +
                '        if (groupedPoints[patternKey].length === 0) continue;\n' +
                '        \n' +
                '        const tabButton = document.createElement(\'button\');\n' +
                '        tabButton.textContent = patternKey + \' (\' + groupedPoints[patternKey].length + \')\';\n' +
                '        tabButton.className = \'px-3 py-2 font-medium text-sm border-b-2 focus:outline-none\';\n' +
                '        tabButton.dataset.target = \'tab-\' + patternKey;\n' +
                '        \n' +
                '        const tabContent = document.createElement(\'div\');\n' +
                '        tabContent.id = \'tab-\' + patternKey;\n' +
                '        tabContent.className = \'table-container\';\n' +
                '        \n' +
                '        const table = document.createElement(\'table\');\n' +
                '        table.className = \'data-table\';\n' +
                '        const headerHTML = \'<thead><tr><th>패턴 No.</th><th>Grid X</th><th>Grid Y</th><th>X</th><th>Y</th></tr></thead>\';\n' +
                '        let rowsHTML = \'\';\n' +
                '        groupedPoints[patternKey].forEach((p, index) => {\n' +
                '            rowsHTML += \'<tr><td>\' + (index + 1) + \'</td><td>\' + p.i + \'</td><td>\' + p.j + \'</td><td>\' + p.x.toFixed(0) + \'</td><td>\' + p.y.toFixed(0) + \'</td></tr>\';\n' +
                '        });\n' +
                '        table.innerHTML = headerHTML + \'<tbody>\' + rowsHTML + \'</tbody>\';\n' +
                '        \n' +
                '        tabContent.appendChild(table);\n' +
                '        \n' +
                '        if (isFirstTab) {\n' +
                '            tabButton.classList.add(\'border-blue-500\', \'text-blue-600\', \'bg-blue-50\');\n' +
                '            tabContent.style.display = \'block\';\n' +
                '            isFirstTab = false;\n' +
                '        } else {\n' +
                '            tabButton.classList.add(\'border-transparent\', \'text-gray-500\', \'hover:text-gray-700\', \'hover:border-gray-200\');\n' +
                '            tabContent.style.display = \'none\';\n' +
                '        }\n' +
                '        \n' +
                '        tabButton.addEventListener(\'click\', (e) => {\n' +
                '            document.querySelectorAll(\'#tab-headers button\').forEach(btn => {\n' +
                '                btn.classList.remove(\'border-blue-500\', \'text-blue-600\', \'bg-blue-50\');\n' +
                '                btn.classList.add(\'border-transparent\', \'text-gray-500\', \'hover:text-gray-700\', \'hover:border-gray-200\');\n' +
                '            });\n' +
                '            document.querySelectorAll(\'#tab-contents > div\').forEach(content => {\n' +
                '                content.style.display = \'none\';\n' +
                '            });\n' +
                '            \n' +
                '            e.target.classList.add(\'border-blue-500\', \'text-blue-600\', \'bg-blue-50\');\n' +
                '            const targetElement = document.getElementById(e.target.dataset.target);\n' +
                '            if (targetElement) targetElement.style.display = \'block\';\n' +
                '        });\n' +
                '        \n' +
                '        tabHeadersContainer.appendChild(tabButton);\n' +
                '        tabContentsContainer.appendChild(tabContent);\n' +
                '    }\n' +
                '}\n' +
                '\n' +
                'function drawPatternVisualization(recipe, dieMapData, intraDiePatterns) {\n' +
                '    if (!recipe || !recipe.inputs || !waferCtx) return;\n' +
                '    \n' +
                '    const { waferDiameter, diePitchX, diePitchY } = recipe.inputs;\n' +
                '    const waferRadius = waferDiameter / 2;\n' +
                '    \n' +
                '    const canvas = waferCanvas;\n' +
                '    const ctx = waferCtx;\n' +
                '    const container = canvas.parentElement;\n' +
                '    canvas.width = container.clientWidth;\n' +
                '    canvas.height = container.clientWidth;\n' +
                '    ctx.clearRect(0, 0, canvas.width, canvas.height);\n' +
                '    \n' +
                '    const padding = 30;\n' +
                '    const scale = Math.min((canvas.width - 2 * padding) / waferDiameter, (canvas.height - 2 * padding) / waferDiameter);\n' +
                '    const centerX = canvas.width / 2;\n' +
                '    const centerY = canvas.height / 2;\n' +
                '    \n' +
                '    // Draw wafer circle\n' +
                '    ctx.beginPath();\n' +
                '    ctx.arc(centerX, centerY, waferRadius * scale, 0, 2 * Math.PI);\n' +
                '    ctx.strokeStyle = \'rgba(255, 0, 0, 0.5)\';\n' +
                '    ctx.lineWidth = 2;\n' +
                '    ctx.stroke();\n' +
                '    \n' +
                '    // Draw pattern points\n' +
                '    if (recipe.results && recipe.results.visibleGroupedPoints) {\n' +
                '        const colors = [\'#FF6B6B\', \'#4ECDC4\', \'#45B7D1\', \'#96CEB4\', \'#FFEAA7\', \'#DDA0DD\', \'#98D8C8\'];\n' +
                '        let colorIndex = 0;\n' +
                '        \n' +
                '        for (const patternKey in recipe.results.visibleGroupedPoints) {\n' +
                '            const points = recipe.results.visibleGroupedPoints[patternKey];\n' +
                '            const color = colors[colorIndex % colors.length];\n' +
                '            \n' +
                '            ctx.fillStyle = color;\n' +
                '            points.forEach(point => {\n' +
                '                const x = centerX + point.x * scale;\n' +
                '                const y = centerY - point.y * scale;\n' +
                '                ctx.beginPath();\n' +
                '                ctx.arc(x, y, 3, 0, 2 * Math.PI);\n' +
                '                ctx.fill();\n' +
                '            });\n' +
                '            \n' +
                '            colorIndex++;\n' +
                '        }\n' +
                '    }\n' +
                '}\n' +
                '\n' +
                '// Copy functionality\n' +
                'if (copyBtn) {\n' +
                '    copyBtn.addEventListener(\'click\', () => {\n' +
                '        const activeTable = document.querySelector(\'#tab-contents > div:not([style*="display: none"]) table\');\n' +
                '        if (!activeTable) return;\n' +
                '        \n' +
                '        let tsvContent = \'\';\n' +
                '        activeTable.querySelectorAll(\'tr\').forEach(row => {\n' +
                '            const rowData = [];\n' +
                '            row.querySelectorAll(\'th, td\').forEach(cell => { rowData.push(cell.innerText); });\n' +
                '            tsvContent += rowData.join(\'\\t\') + \'\\n\';\n' +
                '        });\n' +
                '\n' +
                '        navigator.clipboard.writeText(tsvContent).then(() => {\n' +
                '            toast.classList.add(\'show\');\n' +
                '            setTimeout(() => { toast.classList.remove(\'show\'); }, 2000);\n' +
                '        });\n' +
                '    });\n' +
                '}';
        }

        function generateLineViewer() {
            const lineNameInput = document.getElementById('line-name');
            const lineName = lineNameInput.value.trim();
            
            if (!lineName) {
                alert('라인명을 입력해주세요.');
                return;
            }
            
            const selectedRecipes = getSelectedRecipes();
            if (selectedRecipes.length === 0) {
                alert('내보낼 레시피를 최소 1개 이상 선택해주세요.');
                return;
            }
            
            const now = new Date();
            const generationDate = now.toLocaleString('ko-KR', {
                year: 'numeric',
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            const htmlContent = generateLineViewerHTML(lineName, selectedRecipes, generationDate);
            
            // Create and download the file
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            const dateForFilename = now.toISOString().split('T')[0]; // YYYY-MM-DD format
            a.download = `${lineName}_viewer_${dateForFilename}.html`;
            
            a.click();
            window.URL.revokeObjectURL(url);
            
            alert(`${lineName} 전용 뷰어가 생성되었습니다.\\n파일명: ${a.download}`);
        }

        // --- EVENT LISTENERS FOR LINE VIEWER ---
        document.addEventListener('DOMContentLoaded', function() {
            // Line viewer event listeners
            const selectAllBtn = document.getElementById('select-all-recipes');
            const deselectAllBtn = document.getElementById('deselect-all-recipes');
            const generateBtn = document.getElementById('generate-line-viewer');
            
            if (selectAllBtn) {
                selectAllBtn.addEventListener('click', () => selectAllRecipes(true));
            }
            
            if (deselectAllBtn) {
                deselectAllBtn.addEventListener('click', () => selectAllRecipes(false));
            }
            
            if (generateBtn) {
                generateBtn.addEventListener('click', generateLineViewer);
            }
            
            // Update recipe selection list when recipes are loaded
            const originalDisplayRecipeList = displayRecipeList;
            window.displayRecipeList = function() {
                originalDisplayRecipeList();
                updateRecipeSelectionList();
                
                // Show line viewer section when recipes are loaded
                const lineViewerSection = document.getElementById('line-viewer-section');
                if (loadedRecipes.length > 0 && lineViewerSection) {
                    lineViewerSection.classList.remove('hidden');
                }
            };
        });

    </script>
</body>
</html>